/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <gtk/gtk.h>

#include "main.h"
#include "interface.h"
#include "support.h"
#include "../core/ipmsg.h"
#include "../core/ipmsg_protocol.h"
#include "../core/userUtils.h"
#include "../core/messageUtils.h"
#include "callbacks.h"
#include <sys/socket.h>
#include <sys/types.h>
#include <stdio.h>
#include <netinet/in.h>
#include <string.h>
#include <pthread.h>
#include <stdlib.h>

socket_fd udp_sockfd;
struct sockaddr_in my_address;
int quit =0;
extern GtkWidget *window1;

int
main (int argc, char *argv[])
{
    GtkWidget *window1;

#ifdef ENABLE_NLS
    bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
    bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
    textdomain (GETTEXT_PACKAGE);
#endif

    gtk_set_locale ();

    if (!g_thread_supported())
        g_thread_init(NULL);
    gdk_threads_init();

    gtk_init (&argc, &argv);

    add_pixmap_directory ("./pixmaps");

    udp_sockfd = socket(AF_INET,SOCK_DGRAM,0);
	my_address.sin_family = AF_INET;
	my_address.sin_addr.s_addr = htonl(INADDR_ANY);
	my_address.sin_port = htons(2425);

    //绑定UDP socket
	bind(udp_sockfd, (struct sockaddr *)&my_address,
		(socklen_t)(sizeof(my_address)));

	create_user_list();//创建用户列表
	create_msg_list();//创建消息列表

	login();

    //g_thread_create(recv_udp_packets_thread,NULL,TRUE,NULL);
    //g_thread_create(process_messages_thread,NULL,TRUE,NULL);

    /*
    * The following code was added by Glade to create one of each component
    * (except popup menus), just so that you see something after building
    * the project. Delete any components that you don't want shown initially.
    */
    window1 = create_window1 ();
    gtk_widget_show (window1);
    g_thread_create(recv_udp_packets_thread,NULL,TRUE,NULL);
    g_thread_create(process_messages_thread,NULL,TRUE,NULL);

    gdk_threads_enter();
    gtk_main ();
    gdk_threads_leave();
    return 0;
}

void login()
{
	int so_broadcast=1;
	struct sockaddr_in client_address;
	int client_addr_len;
	char *user_name, host_name[HOST_NAME_LEN];

    //clear_user();
	user_name = (char *)getlogin();
	if ( 0 != gethostname(host_name, HOST_NAME_LEN) )
		strcpy(host_name, "HostName");

	client_address.sin_family = AF_INET;
	client_address.sin_port = htons(2425);
	client_address.sin_addr.s_addr = inet_addr("255.255.255.255");
	bzero(&(client_address.sin_zero),8);

	setsockopt(udp_sockfd,SOL_SOCKET,SO_BROADCAST,
		&so_broadcast,sizeof(so_broadcast));

	command_word command;
	command = IPMSG_BR_ENTRY;
	char send_buf[COMLEN];

	//生成广播消息，应重新设计一个函数来生成消息,待完成......
	int buf_len=sprintf(send_buf, "1:1:%s:%s:%u:%s", user_name, host_name, (unsigned int)command, user_name);

	client_addr_len = sizeof(client_address);
	if (-1 == sendto(udp_sockfd, send_buf,buf_len, 0,
		(struct sockaddr*)&client_address, client_addr_len)) {
		perror("\nbroadcast error");
	}
}



//接收UDP数据包的线程
void* recv_udp_packets_thread()
{
    /*while(1){
	    //gdk_threads_enter();
        printf("\nHello,i am recv_udp_packets_thread");
        sleep(1);
        //gdk_threads_leave();
    }*/
	char recv_buf[COMLEN];
	int buf_len;
	struct sockaddr_in client_address;
	socklen_t client_addr_len = sizeof(client_address);

	while (!quit) {
		buf_len = recvfrom(udp_sockfd, recv_buf, COMLEN, 0,
			(struct sockaddr *)&client_address, &client_addr_len);
		if (buf_len == -1) {
			perror("\nrecv error");
			return 0;
		}
		//printf("\n%s",recv_buf);
		recv_buf[buf_len] = '\0';
		parse_udp(recv_buf, buf_len, client_address);
	}
	return 0;
}

//处理消息的线程
void* process_messages_thread()
{

	/*while(1){
	    //gdk_threads_enter();
        printf("\nHello,i am process_messages_thread");
        sleep(1);
        //gdk_threads_leave();
    }*/
	msg m;
	while (!quit) {
		if (0 == get_msg(&m)) {
			switch (m.command & 0x000000FF) {//处理消息，待完成......
            case IPMSG_NOOPERATION: //不进行任何操作
                //printf("\ni am IPMSG_NOOPERATION");
                break;
            case IPMSG_BR_ENTRY:
                //printf("\ni am IPMSG_BR_ENTRY");
                //printf("\nsomeone broadcast");
                insert_user(m.sender_name, m.sernder_host_name, m.extra_msg, m.sender_addr);
                send_udp_packet(IPMSG_ANSENTRY, NULL, m.sender_addr);
                break;
            case IPMSG_BR_EXIT:
                //printf("\ni am IPMSG_NOOPERATION");
                break;
            case IPMSG_ANSENTRY:
                //printf("\ni am IPMSG_ANSENTRY");
                insert_user(m.sender_name, m.sernder_host_name, m.extra_msg, m.sender_addr);
                refrush(window1,NULL);
                break;
            case IPMSG_SENDMSG:
                //printf("\nrecv one message");
                recv_msg(m);
                insert_recv_msg(m);
		//printf("\n%s",m.extra_msg);
		break;
            case IPMSG_RECVMSG:

                break;

            default:
                //printf("\ni am default");
                break;
			}
		}
		else {
			//printf("\nmessage list is empty.");
			//sleep(200);//暂时没消息，睡眠等待一会，以免浪费CPU时间
		}
	}

	return 0;
}


//处理UDP数据包
void parse_udp(char* udp, int len, struct sockaddr_in sender_addr)
{
	char* end;
	char* start;
	start = udp;
	end = 0;
	char tmp_buf[6][COMLEN/6];
	int tmp_index = 0;

	do {
		end = strpbrk(start, ":");//得到start串中第一个':'号的地址，若没有则返回0
		if (0 != end && end < (udp+len)) {
			strncpy(tmp_buf[tmp_index], start, (int)(end-start));
			tmp_buf[tmp_index][(int)(end-start)] = '\0';
			start = end + 1;
			tmp_index++;
		}
	} while (0 != end);

	strcpy(tmp_buf[tmp_index], start);

	//将分析结果插入消息列表
	insert_msg(atoi(tmp_buf[0]), atoi(tmp_buf[1]), tmp_buf[2], tmp_buf[3],
		strtoul(tmp_buf[4], NULL, 10), tmp_buf[5], sender_addr);
	//show_msg_list();
	//printf("\nfinish");
}

